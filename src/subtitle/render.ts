/**
 * Subtitle Rendering Module
 *
 * Renders subtitle cues to WebVTT format
 */
import type { SubtitleCue, YouTubeTimedTextResponse } from '../types/subtitle.js';

/**
 * Render subtitle cues to WebVTT format
 */
export function renderWebVTT(cues: SubtitleCue[], options?: {
  kind?: string;
  language?: string;
}): string {
  const kind = options?.kind || 'captions';
  const language = options?.language || 'zh-CN';

  let vtt = 'WEBVTT\n';
  vtt += `Kind: ${kind}\n`;
  vtt += `Language: ${language}\n\n`;
  vtt += 'NOTE\n';
  vtt += 'Generated by YouTube Subtitle Proxy\n\n';

  for (let i = 0; i < cues.length; i++) {
    const cue = cues[i];

    // Cue identifier
    vtt += `${i + 1}\n`;

    // Timestamp
    const startTime = formatTimestamp(cue.startTime);
    const endTime = formatTimestamp(cue.endTime);
    vtt += `${startTime} --> ${endTime}\n`;

    // Text (escape special characters)
    const text = escapeWebVTT(cue.text);
    vtt += `${text}\n\n`;
  }

  return vtt;
}

/**
 * Render subtitle cues to YouTube timedtext JSON format
 */
export function renderYouTubeTimedText(cues: SubtitleCue[]): YouTubeTimedTextResponse {
  const events = cues.map(cue => ({
    tStartMs: Math.floor(cue.startTime),
    dDurationMs: Math.floor(cue.endTime - cue.startTime),
    segs: [{ utf8: cue.text }],
  }));

  return {
    events,
    wireMagic: 'pb3',
  };
}

/**
 * Format milliseconds to WebVTT timestamp
 */
function formatTimestamp(ms: number): string {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  const milliseconds = Math.floor(ms % 1000);

  return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(seconds, 2)}.${pad(milliseconds, 3)}`;
}

/**
 * Pad number with leading zeros
 */
function pad(num: number, length: number): string {
  return num.toString().padStart(length, '0');
}

/**
 * Escape special characters for WebVTT
 */
function escapeWebVTT(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/-->/g, '--&gt;')
    .trim();
}

/**
 * Create bilingual subtitle cue
 */
export function createBilingualCue(
  startTime: number,
  endTime: number,
  originalText: string,
  translatedText: string
): SubtitleCue {
  return {
    startTime,
    endTime,
    text: `${originalText}\n${translatedText}`,
  };
}

/**
 * Merge original and translated cues
 */
export function mergeBilingualCues(
  originalCues: SubtitleCue[],
  translatedCues: SubtitleCue[]
): SubtitleCue[] {
  if (originalCues.length !== translatedCues.length) {
    throw new Error('Original and translated cues length mismatch');
  }

  const bilingualCues: SubtitleCue[] = [];

  for (let i = 0; i < originalCues.length; i++) {
    const original = originalCues[i];
    const translated = translatedCues[i];

    bilingualCues.push(
      createBilingualCue(
        original.startTime,
        original.endTime,
        original.text,
        translated.text
      )
    );
  }

  return bilingualCues;
}

export default {
  renderWebVTT,
  renderYouTubeTimedText,
  createBilingualCue,
  mergeBilingualCues,
};
